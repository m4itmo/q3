---
title: Методический материал
draft: false
---

[source](https://dbcourse.yonote.ru/share/a5c04212-5b70-4881-ad01-51ce69969820/doc/metodicheskij-material-64kPu1Lat7)

**PostgreSQL** — это *реляционная система управления базами данных* (РСУБД). Это означает, что это система управления данными, представленными в виде ***отношений* (relation)**. **Отношение** — это математически точное обозначение **_таблицы_**. Хранение данных в таблицах так распространено сегодня, что это кажется самым очевидным вариантом, хотя есть множество других способов организации баз данных. Например, файлы и каталоги в Unix-подобных операционных системах образуют иерархическую базу данных, а сегодня активно развиваются объектно-ориентированные базы данных.

Любая таблица представляет собой именованный набор **_строк (картежей)_**. Все строки таблицы имеют одинаковый набор именованных **_столбцов (аттрибутов)_**, при этом каждому столбцу назначается определённый тип данных. Хотя порядок столбцов во всех строках фиксирован, важно помнить, что SQL не гарантирует какой-либо порядок строк в таблице (хотя их можно явно отсортировать при выводе).

**Таблицы** объединяются в **базы данных**, а набор **баз данных**, управляемый одним экземпляром сервера PostgreSQL, образует ***кластер* баз данных**.

Официальная документация Postgres c общим листингом SELECT: https://www.postgresql.org/docs/current/sql-select.html

# ЛАБА 1

==WHERE== ==ORDER BY== ==DISTINCT== ==LIKE== ==aggregate func==

Чтобы получить данные из таблицы, нужно выполнить **_запрос_**. Для этого предназначен SQL-оператор `SELECT`. Он состоит из нескольких частей: выборки (в которой перечисляются столбцы, которые должны быть получены), списка таблиц (в нём перечисляются таблицы, из которых будут получены данные) и необязательного условия (определяющего ограничения). Например, чтобы получить все строки таблицы product, введите:

`SELECT * FROM production.product;`

Здесь \* — это краткое обозначение «всех столбцов». Также мы можем явно указать столбцы, которые хотим получить:

`SELECT productid, name FROM production.product;`

В списке выборки вы можете писать не только ссылки на столбцы, но и выражения. Например, вы можете написать:

`SELECT productid, name, listprice - standardcost AS discountsize`

`FROM production.product;`

Обратите внимание, как предложение AS позволяет переименовать выходной столбец. (Само слово AS можно опускать.)

Запрос можно дополнить «условием», добавив предложение WHERE, ограничивающее множество возвращаемых строк. В предложении WHERE указывается логическое выражение (проверка истинности), которое служит фильтром строк: в результате оказываются только те строки, для которых это выражение истинно. В этом выражении могут присутствовать обычные логические операторы (AND, OR и NOT).

`SELECT name, listprice, color`

`FROM production.product`

`WHERE listprice = 3578.27 AND (size = '62' OR color = 'Red');`

Оператор IN определяет принадлежность значения одному и значений в списке

`SELECT name, color FROM production.product`

`WHERE color IN ('Red','Black','Silver');`

Вы можете получить результаты запроса в определённом порядке:

`SELECT firstname, middlename, lastname`

`FROM person.person`

`ORDER BY firstname ASC, middlename DESC, lastname ASC;`

Также вы можете ограничить количество выводимых строк:

`SELECT name, listprice`

`FROM production.product`

`ORDER BY listprice DESC`

`LIMIT 5;`

Если требуется, вы можете убрать дублирующиеся строки из результата запроса:

`SELECT DISTINCT color, size`

`FROM production.product;`

При работе со строковыми значениями возникает необходимость проверки на соответствие значения не строке, а шаблону, например, требуется найти все продукты, начинающиеся на букву ‘D’. Для этого используется оператор LIKE:

`SELECT name FROM production.product`

`WHERE name LIKE 'D%';`

Тема регулярок достаточно обширна, поэтому советую ознакомиться с ней в оф. документации: https://www.postgresql.org/docs/current/functions-matching.html

В реляционных базах данных существует особое значение – NULL. Он сообщает пользователям, что в данный момент времени значение атрибута не определено. Для работы с этим значением нельзя использовать оператор сравнения на равенство или любой другой оператор сравнения. Проверка на определенность осуществляется с помощью оператора IS.

`SELECT name FROM production.product`

`WHERE color IS NULL;`

Данный запрос возвращает название товаров, для которых цвет не определен.

`SELECT name FROM production.product`

`WHERE color IS NOT NULL;`

Этот запрос возвращает название товаров, у которых определен размер, т.е. он не является NULL.

Для того чтобы посчитать количество записей в таблице воспользуемся агрегатной функцией. Агрегатные функции вычисляют одно значение над некоторым набором строк. Для того чтобы посчитать сколько у нас записей в таблице продукт:

`SELECT count(*) FROM production.product;`

Или максимальная цена продукта красного цвета:

`SELECT max(listprice) FROM production.product`

`WHERE color = 'Red';`

Список функций:

https://www.postgresql.org/docs/current/functions-aggregate.html
