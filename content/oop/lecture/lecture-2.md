
Три принципа (механизма ООП):
	Инкапсуляция
	Наследование
	Полиморфизм


Инкапсуляция - принцип, согласно которому любой класс, и в более широком смысле - любая часть системы должны рассматриваться как "черный ящик": пользователь класса или подсистемы должен видеть только интерфейс (т.e. список декларируемых свойств и методов) и не вникать во внутреннюю реализацию

- Позволяет мниимизировать число связей между классами и подсистемами и, соотвественно, упростить независимую реализацию и модификацию классов и подсистем
________
Наследование - возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласа), добавляя при необходимости новые свойства и методы

-  Наследование - очень сильная связь между двумя классами
- Помогает переиспользовать код и неразрывно связано с понятием полиморфизма

(Композиция, агрегация?)

Классы автоматически наследуются от Object

Сущность - интерфейс (как правило название интерфейса начинается с I)
- У полей интерфейса нельзя указать модификатор доступа (по умолчанию публичные)
- У интерфейса нет полей, конструктора
```C#
namespace Lec2_Inheritance
{
	public interface IMortal
	{
		bool isAlive { get; }
	}
}
```

```C#
namespace Lec2_Inheritance
{
	public interface ICanStop
	{
		bool Stop();
	}
}
```

```C#
namespace Lec2_Inheritance
{
	public interface ICanFly : ICanStop
	{
		bool IsFlying { get; }
		void Fly();
	}
}
```

```C#
namespace Lec2_Inheritance
{
	public interface ICanSwim : ICanStop
	{
		bool IsSwimming { get; }
		void Swim();
	}
}
```

В шарпах есть ограничение: 
- У одного класса может быть один класс родителей
- Но!!! Класс может реализовывать сколько угодно интерфейсов
- Интерфейсы можно наследовать от других интерфейсов

```C#
namespace Lec2_Inheritance
{
	public abstract class Animal : Imortal, ICanStop
	{
		%% Свойство %%
		public bool IsAlive {get; private set; } = true;
		
		%% Cвойство (виртуальное, значит можно переопределить в наследниках 
			класса) %%
		public virtual string Status => $"{GetType().Name} {GetHashCode()}: {(IsAlive ? "alive" : "dead")}";
		
		public abstract bool Stop();
		
		protected bool Die()
		{
			if (IsAlive)
			{
				IsAlive = false;
				return true;
			}
			else
			{
				return false;
			}
		}
	}
}
```


Абстрактный класс позволяет объявлять абстрактные методы (есть метод, но нет реализации), обязывает классы наследники реализовывать абстрактные методы
- Нельзя иметь нескольких абстрактных классов родителей
- В абстрактном классе можно (и нужно скорее всего) реализовывать методы
- Нельзя создать экземпляр абстрактного класса (некоторые методы могут быть не реализованы)
- Для конструктора абстрактного класса подойдет protected

Члены класса:
1) Поля
2) Свойства
3) События
4) Методы
5) Конструкторы, еструкторы

??? Вопросы (отличия virtual от abstract)
C# 

Память в C#:
Есть куча, есть стек

Типы:
- Значимые (аллоцируются сразу на стеке, являются наследниками типа ValueType)
- Ссылочные (ссылки размещаются в стеке, сама память выделяется на куче)

Все классы по умолчанию - ссылочные, а структуры - значимые

Значимый тип => Ссылочный: называется boxing (например int кастят к объекту)

```C#
namespace Lec2_Inheritance
{
	public abstraсt class Bird : Animal, ICanFly
	{
		public override string Status => $"{base.Status}: {(IsFlying ? "flying" : "not flying")}";

		public bool IsSwimmint { get;}
	
	}

	
%% не дописал %%

}
```




Полиморфизм - возможность использовать классы - потомки в контексте, в котором указаны их классы-родители

- Ad-hoc полиморфизм (статический) - перегрузка, overload (на этапе компиляции компилятор знает, что будет вызвано)
- Параметрический полиморфизм (обобщенные методы, шаблоны)
- Полиморфизм подтипов (который имеется в виду в контексте ООП) -  возможность использовать классы-потомки в контексте, в котором указаны их классы-родители